---
title: "Workflow Stan"
author: "Steffen Ernst"
date: "2023-05-01"
output: html_document
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
if (!require("pacman")) install.packages("pacman"); library(pacman)
p_load(tidyverse, janitor, knitr, forcats, bayesplot, RcppParallel,rstan, BayesFactor, bridgesampling, loo, reticulate, papaja, patchwork)
#setwd("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit")

knitr::opts_knit$set(root.dir = "C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit")

options(mc.cores = parallel::detectCores())

```


```{python npy dataset in python}
import numpy as np
posterior_samples_mrw = np.load("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/STAN/local_post_samples_mrw.npy") # posteriors as ndarray
```

```{r load data and transfer from python to R}
posterior_samples_mrw <- py$posterior_samples_mrw #import into R environment
#df <- read_csv("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Experiment/Daten/Daten_cleaned/special/df_min.csv")
df <- read_csv("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Experiment/Daten/Daten_cleaned/special/color_discrimination_data.csv")
```

```{r wiener-process function}
wiener_process <- function (v=1, a=1, z=0.5, ndt=0.3) {
  # Standard DDM Model Parameters
  # v   = drift rate
  # a   = boundary separation
  # z   = starting point; = 0.5 corresponds to no bias
  # ndt = non-decision time in s
  
  max_iter <- 1e4 # maximum process duration in ms
  dt <- 0.001    # time steps
  sd <- 1        # sd for noise
  sqrt_dt <- sqrt(dt*sd)
  
  # initialize diffusion path for current trial
  path <-  a * z
  # sample diffusion process noise
  noise <- rnorm(max_iter, 0, 1)
  
  # evidence accumulation process
  iter <- 1
  while (path > 0 & path < a & iter < max_iter) {
    path <- path + v*dt + sqrt_dt*noise[iter]
    iter <- iter + 1
  }
  
  # return response time [s] and choice [0, 1]
  return(c(ndt + iter*dt, as.numeric(path > a)))
}
```


```{r function generate parameter plot}
generate_parameter_plot <- function(data, parameter_type) { #warning! depends on condition <- df_temp$speed_condition
  if (parameter_type == "v") {
    title <- substitute(paste("drift rate (", italic("v"), ")"))
    mean_bf <- sym(names(data)[2])
    mean_stan <- sym(names(data)[4])
    sd_bf <- sym(names(data)[3])
    sd_stan <- sym(names(data)[5]) 
  } else if (parameter_type == "a") {
    columns <- c(1, 6:9)
    title <- substitute(paste("Entscheidungsschwelle (", italic("a"), ")"))
    mean_bf <- sym(names(data)[6])
    mean_stan <- sym(names(data)[8])
    sd_bf <- sym(names(data)[7])
    sd_stan <- 0
  } else if (parameter_type == "ndt") {
    columns <- c(1, 10:13)
    title <- substitute(paste("non-decision-time (", italic("ndt"), ")"))
    mean_bf <- sym(names(data)[10])
    mean_stan <- sym(names(data)[12])
    sd_bf <- sym(names(data)[11])
    sd_stan <- sym(names(data)[13])
  } else {
    stop("Invalid parameter_type. Use 'v', 'a', or 'ndt'.")
  }
  
  ymax <- max(data %>%
  rowwise() %>%
  mutate(max_expr = pmax(!!mean_bf + !!sd_bf, !!mean_stan + !!sd_stan)) %>%
  pull(max_expr), na.rm = TRUE)
  ymin <- min(data %>% 
                rowwise() %>% 
                mutate(min_expr = pmin(!!mean_bf - !!sd_bf, !!mean_stan - !!sd_stan)) %>%
  pull(min_expr), na.rm = TRUE)
  
  firstcolour <- ifelse(condition[1]==1, "gray60", "gray40")# gray60 = speedcondition
  secondcolour <- ifelse(firstcolour == "gray60", "gray40", "gray60")
  rects <- data.frame(xstart = seq(0.5,336.5,48), xend = seq(48.5,384.5,48), 
                      col = rep(c(firstcolour, secondcolour), 4))
  
  p1 <- data %>% 
    slice(1:384) %>% 
    ggplot() +
    geom_rect(data=rects, aes(ymin=ymin, ymax=ymax, xmin=xstart,
                            xmax=xend, fill=col), alpha =0.5) +
    geom_line(aes(x = 1:384, y = !!mean_bf), color = "firebrick", linewidth = 1) +
    geom_line(aes(x = 1:384, y = !!mean_stan), color = "steelblue", linewidth = 1) +
    geom_ribbon(aes(x = 1:384, ymin = !!mean_bf - !!sd_bf, ymax = !!mean_bf + !!sd_bf), fill = "firebrick", alpha = 0.5) +
    geom_ribbon(aes(x = 1:384, ymin = !!mean_stan - !!sd_stan, ymax = !!mean_stan + !!sd_stan), fill = "steelblue", alpha = 0.5) +
    scale_x_continuous(breaks = c(1,seq(96, 384, 96))) + 
    scale_fill_manual(
        values = c(
    "gray60" = "gray60", 
    "gray40" = "gray40",
    "firebrick1" = alpha("firebrick", 1),  # Post. Mittelw. with alpha=1
    "firebrick05" = alpha("firebrick", 0.5),  # Post. SD with alpha=0.5
    "steelblue1" = alpha("steelblue", 1),  # fast-dm Schätzung with alpha=1
    "steelblue05" = alpha("steelblue", 0.5)  # fast-dm inter-trial-var. with alpha=0.5
  )
    ) + 
        labs(
      title = title,
      x = "Trialzahl",
      y = "Parameterwert",
      labs(fill = "")
    ) +
    ylim(ymin, ymax) +  
    theme_apa() +
    theme(axis.title.x = element_text(hjust = 0),
          legend.position = "none")
  # Adjust hjust to move the x-axis label to the left


p2 <- data %>%
  slice(385:768) %>%
  ggplot() +
  geom_rect(data=rects, aes(ymin=ymin, ymax=ymax, xmin=xstart, xmax=xend, fill=col), alpha =0.5) + 
  geom_line(aes(x = 1:384, y = !!mean_bf, color = "firebrick"), linewidth = 1) +
  geom_line(aes(x = 1:384, y = !!mean_stan, color = "steelblue"), linewidth = 1) +
  geom_ribbon(aes(x = 1:384, ymin = !!mean_bf - !!sd_bf, ymax = !!mean_bf + !!sd_bf, fill = "firebrick05")) + #, alpha = 0.5
  geom_ribbon(aes(x = 1:384, ymin = !!mean_stan - !!sd_stan, ymax = !!mean_stan + !!sd_stan, fill = "steelblue05")) + #,alpha = 0.5 
  labs(
    title = element_blank(),
    x = element_blank(),
    y = element_blank()
  ) +
  theme_apa() +
  theme(
    legend.title = element_text(size=7), 
    legend.text=element_text(size=7),
    legend.position = "bottom",
    legend.margin=margin(0,0,0,0),
    legend.box.margin=margin(0,0,0,0),
    legend.box.spacing = unit(0, "pt")
  ) +
  scale_x_continuous(breaks =c(breaks = c(1,seq(96, 384, 96))), labels = c(385,seq(480, 768, 96))) +
  scale_color_manual(
    values = c(
      "firebrick" = "firebrick", 
      "steelblue" = "steelblue"
    ),
    limits = c(
      "firebrick", 
      "steelblue"
    ),
    labels = c(
      "Post. Mittelw.",
      "fast-dm Schätzung"
    ),
    name = ""
  ) +
  scale_fill_manual(
    values = c(
    # "firebrick" = alpha("firebrick", 1),  # Post. Mittelw. with alpha=1
      "firebrick05" = alpha("firebrick", 0.5),  # Post. SD with alpha=0.5
     # "steelblue" = alpha("steelblue", 1),  # fast-dm Schätzung with alpha=1
      "steelblue05" = ifelse(parameter_type=="a", "white", alpha("steelblue", 0.5)),  # fast-dm inter-trial-var. with alpha=0.5
      "gray60" = "gray60",  # Geschwindigkeitsbedingung
      "gray40" = "gray40"  # Genauigkeitsbedingung
    ),
    limits = c(
    #  "firebrick", 
      "firebrick05", 
    #  "steelblue", 
      "steelblue05", #can be white inside! 
      "gray60", 
      "gray40"
    ),
    labels = c(
     # "Post. Mittelw.", 
      "Post. SD", 
      #"fast-dm Schätzung", 
       ifelse(parameter_type=="a",element_blank(),"fast-dm inter-trial-var."),
      "Geschwindigkeitsbedingung", 
      "Genauigkeitsbedingung"
    ),
    name = ""
  )  +
  guides(
    color = guide_legend(order = 1, nrow = 2),
    fill = guide_legend(order = 2, nrow = 2)
                    #    override.aes = list(color = c("steelblue", "firebrick")))

  )+
  labs(
    title = element_blank(),
    x = element_blank(),
    y = element_blank()
  ) +
  ylim(ymin, ymax) +  
  #theme_apa() +
  theme(
    legend.title = element_text( size=7), 
    legend.text=element_text(size=7),
    legend.position = "bottom",
    legend.margin=margin(0,0,0,0),
    legend.box.margin=margin(0,0,0,0),
    legend.box.spacing = unit(0, "pt")
  )
  
  
  parameter_comparison <- p1 / p2 # + plot_layout(widths = c(2, 1))
  return(parameter_comparison)
}

```



Alle Modelle laden.
```{r load all STAN Models, create loos}
#takes a long time to load
filenames <- list.files("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/STAN", pattern="*.rds", full.names=TRUE)
ldf <- lapply(filenames, read_rds)

filenames_shortened <-str_sub(filenames, start = -18, end = -5)
filenames_shortened <- gsub("^(?!s)", "s", filenames_shortened, perl = T)
for (i in 1:length(ldf)) {
  ldf[[i]]@model_name <- filenames_shortened[i]
}
#create a list with loo for all models, takes a LONG time
loo_list <-  list()
for (i in 1:length(ldf)) {
  loo_list[[i]] <- loo(ldf[[i]])
}
names(loo_list) <-  filenames_shortened
#create a list with comparisons for all subjects
loocomparison_list <-  list()
j=1
for (i in 1:(length(ldf)/2)) {
  loocomparison_list[[i]] <-  loo_compare(loo_list[[j]],loo_list[[j+1]])
  j=j+2

}
results = c(2, 2, 1, 2, 2, 1, 2, 1, 1, 2, 2, 2, 1, 2)
```

creates graphs for parameter comparison as well as rt comparison, both for 14 people individually and the later also for all
```{r data resimulation for rt comparison}




set.seed(123)
person=1 #person
resimulation=1 #1 of 100 resimulations 
trial=1 #1 of 768 trials

#ldf is weirdly sorted ( 1,10,11, and so on) so we create "position" which finds the correct position in ldf to chose for person

ldf_id <- c(15, 1, 16, 10, 17, 11, 18, 12, 19, 13, 20, 14, 21, 2, 22, 3, 23, 4, 24, 5, 25, 6, 26, 7, 27, 8, 28, 9)
position <- match(1:length(ldf_id), ldf_id) # Use the match function to find positions

simulation_complete_all_14people <-  tibble()

for (person in 1:14) { #unique(df$id)
  df_temp <- df %>% filter(id==person,
                           tutorial==0)
  rt <- df_temp$rt
  min_rt <- min(rt)
  correct <- df_temp$correct
  difficulty <- df_temp$difficulty
  condition <- df_temp$speed_condition
  condition2 <- ifelse(df_temp$speed_condition==1, 4,0)
  N <- nrow(df_temp)
  simulation_complete_stan <-  tibble(response_time_fake = double(), correct_fake = integer(), trial = integer(), difficulty = integer(), condition = integer()) #empty tibbles for stan Simulation
  simulation_complete_bf <-  tibble(response_time_fake = double(), correct_fake = integer(), trial = integer(), difficulty = integer(), condition = integer()) #empty tibbles for bayesflow simulation
  posterior_samples_stan <- rstan::extract(ldf[[position[person]]], pars = c("v[1]", "v[2]", "v[3]", "v[4]","v[5]","v[6]","v[7]","v[8]", "a[1]", "a[2]", "ndt"))
  results_df <- data.frame(
    instance = 1:length(posterior_samples_stan)-1,
    mean = sapply(posterior_samples_stan, mean),
    sd  = sapply(posterior_samples_stan, sd)
  )
  
  
  #posterior_samples_mrw were created already.
    data <- data.frame( #calculates mean and sd for all posteriors for bf and stan
    dimension = 1:768,
    mean_v_bf = rowMeans(posterior_samples_mrw[person, , , 1]),
    sd_v_bf = apply(posterior_samples_mrw[person, , , 1], 1, sd),
    mean_v_stan = results_df$mean[difficulty+1+ condition2],
    sd_v_stan = results_df$sd[difficulty+1],
    mean_a_bf = rowMeans(posterior_samples_mrw[person, , , 2]),
    sd_a_bf = apply(posterior_samples_mrw[person, , , 2], 1, sd),
    mean_a_stan = results_df$mean[9 + condition],
    sd_a_stan = results_df$sd[9 + condition],
    mean_ndt_bf = rowMeans(posterior_samples_mrw[person, , , 3]),
    sd_ndt_bf = apply(posterior_samples_mrw[person, , , 3], 1, sd),
    mean_ndt_stan = results_df$mean[11],
    sd_ndt_stan = results_df$sd[11]
    
  )
  generate_parameter_plot(data, "v")
  ggsave(paste0("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Bilder/parameter_comparison/parametercomparison_subj_", person, "_v.png"),  width = 7500, height = 5000, units = "px", dpi = 600)

generate_parameter_plot(data, "a")
    ggsave(paste0("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Bilder/parameter_comparison/parametercomparison_subj_", person, "_a.png"),  width = 5000, height = 3500, units = "px", dpi = 800)
    
  generate_parameter_plot(data, "ndt")
  ggsave(paste0("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Bilder/parameter_comparison/parametercomparison_subj_", person, "_ndt.png"),  width = 5000, height = 3500, units = "px", dpi = 800)

  #NEW PLOT: true rt vs predicted rts

posterior_samples_bf <- posterior_samples_mrw[, , sample(1:4000, 100), ] #trim array to 100 of 4000 estimations
  posterior_samples_stan <- rstan::extract(ldf[[position[person]]], pars = c("v[1]", "v[2]", "v[3]", "v[4]","v[5]","v[6]","v[7]","v[8]", "a[1]", "a[2]", "ndt"))
  parameters_to_sample <- c("v[1]", "v[2]", "v[3]", "v[4]", "v[5]", "v[6]", "v[7]", "v[8]", "a[1]", "a[2]", "ndt")
  # Use lapply to sample each parameter
  posterior_samples_stan <- lapply(parameters_to_sample, function(param) {
  sample(posterior_samples_stan[[param]], 100, replace = FALSE) #trim the other one as well
})
    for (resimulation in 1:100) {
      #j = 1 set of resimulation with hardcoded v1-4 and a1-2. which v and a still need to be decided
      
      rt_sim_stan <- c()
      correct_sim_stan <-  c()
      rt_sim_bf <- c()
      correct_sim_bf <-  c()
      
      #tibble(response_time_fake = double(), correct_fake = integer(), trial = integer(), difficulty = integer(), condition = integer())
      for (trial in 1:768) {
        v <- posterior_samples_stan[[1 + difficulty[trial] + condition2[trial]]] [resimulation] #difficulty[trial]  and condition2[trial] is for choosing which v is to use. [j] is for which of the 100 values of that v to use.
        a <- posterior_samples_stan[[9 + condition[trial]]] [resimulation]
        ndt <- posterior_samples_stan[[11]] [resimulation]
        output <- wiener_process(v = v, a = a, ndt = ndt)
        rt_sim_stan <- c(rt_sim_stan, output[1])
        correct_sim_stan <- c(correct_sim_stan, output[2])
        
        v <- posterior_samples_bf[person,trial,resimulation,1]
        a <- posterior_samples_bf[person,trial,resimulation,2]
        ndt <- posterior_samples_bf[person,trial,resimulation,3]
        output <- wiener_process(v = v, a = a, ndt = ndt) #function creates rt and correct y/n
        rt_sim_bf <- c(rt_sim_bf, output[1])
        correct_sim_bf <- c(correct_sim_bf, output[2])
       }
      
      temp_simulation_stan <- # put all in a temporary df
        tibble(
          response_time_fake = rt_sim_stan,
          correct_fake = correct_sim_stan,
          trial = 1:length(rt_sim_stan),
          difficulty = difficulty,
          condition = condition
        )
       temp_simulation_bf <-
        tibble(
          response_time_fake = rt_sim_bf,
          correct_fake = correct_sim_bf,
          trial = 1:length(rt_sim_bf),
          difficulty = difficulty,
          condition = condition
        )
       
      simulation_complete_stan <- #combine temp dfs in one simulation-df
        bind_rows(simulation_complete_stan, temp_simulation_stan)
      rm(temp_simulation_stan) #rm temp_dfs
      simulation_complete_bf <-
        bind_rows(simulation_complete_bf, temp_simulation_bf)
      rm(temp_simulation_bf)      
      
    }
  
  simulation_complete_all <- bind_rows(
    simulation_complete_bf %>%
      mutate(Berechnung = "BayesFlow"),
    simulation_complete_stan %>%
      mutate(Berechnung = "STAN")
  ) %>% 
    group_by(trial, Berechnung, condition, difficulty) %>%
    summarise(
      median_response_time = median(response_time_fake))
  
  simulation_complete_summary <- simulation_complete_all %>% 
    group_by(Berechnung, condition, difficulty) %>% 
    summarize(
      mean_response_time = mean(median_response_time),
      lower_ci = mean_response_time - qt(0.975, n() - 1) * sd(median_response_time) / sqrt(n()),
      upper_ci = mean_response_time + qt(0.975, n() - 1) * sd(median_response_time) / sqrt(n()),
      condition = if_else(condition==0,"Genauigkeitsbedingung", "Geschwindigkeitsbedingung")
    )
   
  rm(simulation_complete_bf)
  rm(simulation_complete_stan)
  
  # Create a summary dataframe
  #summary_df <- combined_results %>%

  combined_summary <- bind_rows(
    simulation_complete_summary %>% mutate(dataset = "Simulation"),
    df %>%
      filter(tutorial == 0,
             id == person
             ) %>%
      group_by(speed_condition, difficulty) %>%
      summarise(
        mean_response_time = mean(rt),
        lower_ci = mean_response_time - qt(0.975, n() - 1) * sd(rt) / sqrt(n()),
        upper_ci = mean_response_time + qt(0.975, n() - 1) * sd(rt) / sqrt(n()),
        Berechnung = "Real Data",
        condition = if_else(speed_condition==0,"Genauigkeitsbedingung", "Geschwindigkeitsbedingung")
      )
  )
 
  ggplot(data = combined_summary, aes(x = factor(difficulty), y = mean_response_time, color = Berechnung)) +
    geom_point(size = 3, position = position_dodge(width = 0.2)) +
    geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, position = position_dodge(width = 0.2)) +
    geom_line(aes(group = Berechnung), position = position_dodge(width = 0.2), size = 1) +
    labs(x = "Difficulty", y = "Response Time") +
    ggtitle("simulierte und echte Reaktionszeit") +
    geom_hline(yintercept = 0.7, linetype = "dashed") +
    scale_color_manual(
      breaks = c('Real Data', 'BayesFlow', 'STAN'),  # TODO check whether they are in correct order
      values = c('Real Data' = 'grey', 'BayesFlow' = 'red', 'STAN' = 'steelblue')  # Optionally, specify custom colors
    ) +
    theme_apa() +
    facet_wrap(~condition, scales = "free_y")

  #   ggsave(paste0("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Bilder/rt_comparison/rt_comparison_subj_", person, ".png"),  width = 6500, height = 4550, units = "px", dpi = 800)
  #   
    simulation_complete_all_14people <- simulation_complete_all_14people %>% 
        bind_rows(simulation_complete_all)

if (person == tail(1:14,1)) {

   simulation_complete_all_14people_summary <- simulation_complete_all_14people %>% 
       group_by(Berechnung, condition, difficulty) %>% 
    summarize(
      mean_response_time = mean(median_response_time),
      lower_ci = mean_response_time - qt(0.975, n() - 1) * sd(median_response_time) / sqrt(n()),
      upper_ci = mean_response_time + qt(0.975, n() - 1) * sd(median_response_time) / sqrt(n()),
      condition = if_else(condition==0,"Genauigkeitsbedingung", "Geschwindigkeitsbedingung")
    )
  
   combined_summary_all <- bind_rows(
    simulation_complete_all_14people_summary,
    df %>%
      filter(tutorial == 0) %>%
      group_by(speed_condition, difficulty) %>%
      summarise(
        mean_response_time = mean(rt),
        lower_ci = mean_response_time - qt(0.975, n() - 1) * sd(rt) / sqrt(n()),
        upper_ci = mean_response_time + qt(0.975, n() - 1) * sd(rt) / sqrt(n()),
        Berechnung = "Real Data",
        condition = if_else(speed_condition==0,"Genauigkeitsbedingung", "Geschwindigkeitsbedingung")
      )
  )
    
    
    
  ggplot(data = combined_summary_all, aes(x = factor(difficulty), y = mean_response_time, color = Berechnung)) +
    geom_point(size = 3, position = position_dodge(width = 0.2)) +
    geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.2, position = position_dodge(width = 0.2)) +
    geom_line(aes(group = Berechnung), position = position_dodge(width = 0.2), size = 1) +
    labs(x = "Schwierigkeit", y = "Reaktionszeit") +
    ggtitle("simulierte und echte Reaktionszeit") +
    geom_hline(yintercept = 0.7, linetype = "dashed") +
    scale_color_manual(
      #  labels = c('Real Data', 'BayesFlow', 'STAN'),  # Optionally, specify custom labels
            breaks = c('Real Data', 'BayesFlow', 'STAN'),  # TODO check whether they are in correct order
      values = c('Real Data' = 'grey', 'BayesFlow' = 'red', 'STAN' = 'steelblue')  # Optionally, specify custom colors
    ) +
    scale_x_discrete(breaks =c(0,1,2,3), labels = c(1,2,3,4)) +

    theme_apa() +
    facet_wrap(~condition, scales = "free_y")

  ggsave(paste0("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Bilder/rt_comparison/rt_comparison_ALL.png"),  width = 6500, height = 4550, units = "px", dpi = 800)

}
}
```