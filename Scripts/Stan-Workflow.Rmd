---
title: "Workflow Stan"
author: "Steffen Ernst"
date: "2023-05-01"
output: html_document
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
if (!require("pacman")) install.packages("pacman"); library(pacman)
p_load(tidyverse, janitor, forcats, bayesplot, RcppParallel, rstan, BayesFactor, bridgesampling, loo, reticulate, papaja, patchwork)
#setwd("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit")

knitr::opts_knit$set(root.dir = "C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit")

options(mc.cores = parallel::detectCores())

```


```{r wiener-process function}
wiener_process <- function (v=1, a=1, z=0.5, ndt=0.3) {
  # Standard DDM Model Parameters
  # v   = drift rate
  # a   = boundary separation
  # z   = starting point; = 0.5 corresponds to no bias
  # ndt = non-decision time in s
  
  max_iter <- 1e4 # maximum process duration in ms
  dt <- 0.001    # time steps
  sd <- 1        # sd for noise
  sqrt_dt <- sqrt(dt*sd)
  
  # initialize diffusion path for current trial
  path <-  a * z
  # sample diffusion process noise
  noise <- rnorm(max_iter, 0, 1)
  
  # evidence accumulation process
  iter <- 1
  while (path > 0 & path < a & iter < max_iter) {
    path <- path + v*dt + sqrt_dt*noise[iter]
    iter <- iter + 1
  }
  
  # return response time [s] and choice [0, 1]
  return(c(ndt + iter*dt, as.numeric(path > a)))
}
```


```{r Initialization function}
# initialisation function to prevent starting values of MCMC chain outside of possible values for ndt
init = function(chains=4, min_rt) {
  L = list()
  for (c in 1:chains) {
    L[[c]]=list()
    L[[c]]$ndt = runif(1, 0.1, min_rt*0.95)
   
  }
  return (L)
}

```


```{r create STAN Models all participants}
#creates list all_models which consists of 14 lists. In each of the 14 lists there are 2 models
all_models <- list()
set.seed(12345)
#df_min <-  read_csv("Experiment/Daten/Daten_cleaned/special/df_min.csv")
for (i in 1:14) { #unique(df$id)
  df_temp <- df %>% filter(id==i,
                           tutorial==0)
  border <- boxplot.stats(log(df_temp$rt))$stats[1]
  print(table(log(df_temp$rt) > border))
  df_temp <- df_temp %>% filter(log(df_temp$rt) > border)
  

  rt <- df_temp$rt
  min_rt <- min(rt)
  correct <- df_temp$correct
  difficulty <- df_temp$difficulty
  condition <- df_temp$speed_condition
  condition2 <- ifelse(df_temp$speed_condition==1, 4,0)
  N <- nrow(df_temp)
  
  data_list <- list(N = N,
                    rt = rt,
                    correct = correct,
                    difficulty = difficulty,
                    condition = condition,
                    condition2 = condition2)
  model_file <- "C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Skripte/model1.stan"
  fit1 <- stan(
    file = model_file,
    data = data_list,    # name d list of data
    chains = 4,             # number of Markov chains
    warmup = 2000,          # number of warmup iterations per chain
    iter = 4000,#,            # total number of iterations per chain
    init = init(4, min_rt),
    cores = parallel::detectCores()              # number of cores (could use one per chain)
    # refresh = 0             # no progress shown
  )
  saveRDS(fit1, file = paste0("subject_",df_temp[1,"id"] ,"_fit1.rds"))

  model_file <- "C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Skripte/model2.stan"# to do
  fit2 <- stan(
    file = model_file,
    data = data_list,    # named list of data
    chains = 4,             # number of Markov chains
    warmup = 2000,          # number of warmup iterations per chain
    iter = 4000,            # total number of iterations per chain
    cores = parallel::detectCores()              # number of cores (could use one per chain)
    # refresh = 0             # no progress shown
  )
  saveRDS(fit2, file = paste0("subject_",df_temp[1,"id"] ,"_fit2.rds"))
  listname = paste0("fitlist_", df_temp[1,"id"])
  list_temp <- list(fit1 = fit1, fit2 = fit2)
  all_models[[listname]] <- list_temp
}


```

Alle Modelle laden.
```{r load all STAN Models}
filenames <- list.files("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/STAN", pattern="*.rds", full.names=TRUE)
ldf <- lapply(filenames, read_rds)

filenames_shortened <-str_sub(filenames, start = -18, end = -5)
filenames_shortened <- gsub("^(?!s)", "s", filenames_shortened, perl = T)
for (i in 1:length(ldf)) {
  ldf[[i]]@model_name <- filenames_shortened[i]
}
#create a list with loo for all models
```


```{r  create loos}
loo_list <-  list()
ldf_id <- c(15, 1, 
            24, 10, 
            25, 11, 
            26, 12, 
            27, 13, 
            28, 14, 
            16, 2, 
            17, 3, 
            18, 4, 
            19, 5, 
            20, 6, 
            21, 7, 
            22, 8, 
            23, 9)
position <- match(15:28, ldf_id) # Use the match function to find positions
for (i in 1:length(ldf)) {
  loo_list[[i]] <- loo(ldf[[i]])
}
names(loo_list) <-  filenames_shortened
#create a list with comparisons for all subjects
loocomparison_list <-  list()
j=1
for (i in 1:(length(ldf)/2)) {
  loocomparison_list[[i]] <-  loo_compare(loo_list[[j]],loo_list[[j+1]])
  j=j+2

}
results = c(2, 2, 1, 2, 2, 1, 2, 1, 1, 2, 2, 2, 1, 2)

#or load the results:
for (i in loocomparison_list) {
  
}

as.data.frame(loocomparison_list)
loocomparison_list_named <-  loocomparison_list %>% set_names(c(1:14))
bind_rows(loocomparison_list_named)

reorder_rows <- function(df) {
  # Check if 'model1' is in the row names
  if ("model1" %in% rownames(df)) {
    # Move 'model1' to the first row
    df <- df[c("model1", setdiff(rownames(df), "model1")), ]
  }
  return(df)
}

# Apply the reorder_rows function to each data frame in the list
reordered_loocomparison_list <- lapply(loocomparison_list, reorder_rows)
combined_df <- as_tibble(do.call(rbind, reordered_loocomparison_list))
combined_df <- combined_df %>% 
  select("elpd_loo", "se_elpd_loo", "elpd_diff", "se_diff") %>% 
  add_column(Modell =rep(c("M1","M2"), 14), .before = "elpd_loo") %>%
  add_row(Modell = "Versuchsperson 1",.before = 1) %>% 
  add_row(Modell = "Versuchsperson 2",.before = 4) %>% 
  add_row(Modell = "Versuchsperson 3",.before = 7) %>% 
  add_row(Modell = "Versuchsperson 4",.before = 10) %>% 
  add_row(Modell = "Versuchsperson 5",.before = 13) %>% 
  add_row(Modell = "Versuchsperson 6",.before = 16) %>% 
  add_row(Modell = "Versuchsperson 7",.before = 19) %>% 
  add_row(Modell = "Versuchsperson 8",.before = 22) %>% 
  add_row(Modell = "Versuchsperson 9",.before = 25) %>% 
  add_row(Modell = "Versuchsperson 10",.before = 28) %>% 
  add_row(Modell = "Versuchsperson 11",.before = 31) %>% 
  add_row(Modell = "Versuchsperson 12",.before = 34) %>% 
  add_row(Modell = "Versuchsperson 13",.before = 37) %>% 
  add_row(Modell = "Versuchsperson 14",.before = 40)

kable_table <- kable(combined_df, format = "html", digits=2)
kable_table
```


```{python npy load dataset in python}
import numpy as np
posterior_samples_mrw = np.load("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/STAN/local_post_samples_mrw.npy") # posteriors as ndarray
```

```{r load data and transfer from python to R}
posterior_samples_mrw <- py$posterior_samples_mrw #import into R environment
#df <- read_csv("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Experiment/Daten/Daten_cleaned/special/df_min.csv")
df <- read_csv("C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Experiment/Daten/Daten_cleaned/special/color_discrimination_data.csv")
```


```{r if you want to create a single model, eval = FALSE}
df <- read_csv("Experiment/Daten/Daten_cleaned/special/color_discrimination_data.csv")
df <- df %>% 
  filter(tutorial == 0)
  
rt <- df$rt
correct <- df$correct
difficulty <- df$difficulty
condition <- df$speed_condition
condition2 <- ifelse(df$speed_condition==1, 4,0)
N <- nrow(df)

  # Create data list
data_list <- list(N = N,
                    rt = rt,
                    correct = correct,
                    difficulty = difficulty,
                    condition = condition,
                    condition2 = condition2)
```




```{r model1, eval=FALSE}
model_file <- "C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Skripte/model1.stan"
set.seed(12345)
fit1 <- stan(
    file = model_file,
    data = data_list,    # name d list of data
    chains = 4,             # number of Markov chains
    warmup = 2000,          # number of warmup iterations per chain
    iter = 4000,#,            # total number of iterations per chain
    cores = parallel::detectCores(),              # number of cores (could use one per chain)
    # refresh = 0             # no progress shown
  )

saveRDS(fit1, "STAN/fit1.rds")
```

```{r model2, eval=FALSE}
model_file <- "C:/Users/steff/Documents/Universität/Master Psychologie/SS 2022/Masterarbeit/Skripte/model2.stan"

set.seed(12345)
fit2 <- stan(
    file = model_file,
    data = data_list,    # name d list of data
    chains = 4,             # number of Markov chains
    warmup = 2000,          # number of warmup iterations per chain
    iter = 4000,#,            # total number of iterations per chain
    cores = parallel::detectCores()   # number of cores (could use one per chain)
    # refresh = 0             # no progress shown
  )

saveRDS(fit2, "STAN/fit2.rds")
```



```{r load single model, include = FALSE, eval= FALSE}
fit1 <- readRDS("~/Universität/Master Psychologie/SS 2022/Masterarbeit/STAN/subject_1_fit1.rds")
fit2 <- readRDS("~/Universität/Master Psychologie/SS 2022/Masterarbeit/STAN/subject_2_fit2.rds")
```

```{r model1 checks, eval= FALSE}
# Check convergence
print(fit1, par=c("a", "v", "ndt"), digits=2)
print(rstan::stan_rhat(fit1))
#mcmc_trace(fit1)#, pars = "ndt")
stan_trace(fit1)
mcmc_pairs(fit1, pars = c("v[1]", "v[2]", "v[3]", "v[4]", "a[1]"))
mcmc_pairs(fit1, pars = c("a[1]", "a[2]", "ndt"))
mcmc_pairs(fit1, pars = c("v[1]", "v[2]", "v[3]", "v[4]", "a[1]", "a[2]", "ndt"))
  
```

```{r model2 checks, eval= FALSE}
# Check convergence
print(fit2, par=c("a", "v", "ndt"), digits=2)
print(rstan::stan_rhat(fit2))
#mcmc_trace(fit1)#, pars = "ndt")
stan_trace(fit2, pars = c("v[1]", "v[2]", "v[3]", "v[4]", "v[5]", "v[6]", "v[7]", "v[8]"))
mcmc_pairs(fit2, pars = c("v[1]", "v[2]", "v[3]", "v[4]"))
mcmc_pairs(fit2, pars = c("v[5]", "v[6]", "v[7]", "v[8]"))           
mcmc_pairs(fit2, pars = c("v[1]", "v[2]", "v[3]", "v[4]", "a[1]", "a[2]", "ndt"))
mcmc_pairs(fit2, pars = c("v[5]", "v[6]", "v[7]", "v[8]", "a[1]", "a[2]", "ndt"))
mcmc_pairs(fit2, pars = c("v[1]", "v[2]", "v[3]", "v[4]", "v[5]", "v[6]", "v[7]", "v[8]"))
mcmc_pairs(fit2, pars = c("a[1]", "a[2]", "ndt"))

```


Hier sind die Posterio retrodiction Tests:
```{r posterior retrodiction checks, eval= FALSE}

posterior_samples <- rstan::extract(fit1, pars = c("v[1]", "v[2]", "v[3]", "v[4]", "a[1]", "a[2]", "ndt"))
j=1
sim_data <- tibble(response_time_fake = double(), correct_fake = integer())
for (i in 1:nrow(df)) {
  v <- posterior_samples[[1 + difficulty[i]]] [j]
  a <- posterior_samples[[5 + condition[i]]] [j]
  ndt <- posterior_samples[[7]] [j]
  output <- wiener_process(v=v, a=a,ndt=ndt)
  sim_data <- sim_data %>% add_row(response_time_fake = output[1], correct_fake = output[2])
  j <-  ifelse(j>199,1,j+1)
  
}
df_vis <- tibble(sim_data, response_time_real = rt, correct, condition, difficulty)

ggplot(df_vis, aes(x = response_time_fake)) + #, fill = factor(correct))) +
  geom_density()+ #aes(fill = "red")) +
  geom_density(aes(x=response_time_real)) +#aplha = 0.5, fill = "blue")) + 
  facet_grid(difficulty ~ condition,labeller = labeller(difficulty = as.character, 
                               condition = function(x) ifelse(x==1, "Speed", "Accuracy"))) +
  xlim(0,2) +
  labs(title = "RT in Abhängigkeit von Bedingung und Schwierigkeit",
       x = "RT",
       y = "Density",
       fill = "Correct")



df_resp_prob <- df_vis %>%
  group_by(condition, difficulty) %>%
  summarise(resp_prob_real = mean(correct),
            resp_prob_fake = mean(correct_fake)) %>%
  pivot_longer(cols = c(resp_prob_real, resp_prob_fake),
               names_to = "response_type",
               values_to = "response_prob") %>%
  mutate(response_type = factor(response_type,
                                 levels = c("resp_prob_real", "resp_prob_fake"),
                                 labels = c("Real", "Fake")))
df_resp_prob %>%  
  filter(condition == 0) %>% #speed
  ggplot(aes(x = factor(difficulty), y = response_prob, fill = response_type)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), color = "black") +
  scale_fill_manual(values = c("Real" = "steelblue", "Fake" = "firebrick")) +
  labs(x = "Difficulty", y = "Antwortwahrscheinlichkeit", fill = "Datenart") +
  theme_classic() + 
  ggtitle("Speed-Bedingung")

df_resp_prob %>%  
  filter(condition == 1) %>% #accuracy
  ggplot(aes(x = factor(difficulty), y = response_prob, fill = response_type)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), color = "black") +
  scale_fill_manual(values = c("Real" = "steelblue", "Fake" = "firebrick")) +
  labs(x = "Difficulty", y = "Antwortwahrscheinlichkeit", fill = "Datenart") +
  theme_classic() + 
  ggtitle("Speed-Bedingung")

kable(df_resp_prob, format = "markdown", digits = 2, align = "c")
```
